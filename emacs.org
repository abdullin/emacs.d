#+PROPERTY:    tangle build/init-main.el
#+PROPERTY:    eval no-export
#+PROPERTY:    results silent
#+PROPERTY:    header-args:sh  :tangle no

* Introduction

This is a literate version of my base emacs config. You can generate
emacs init script out of it by running =org-babel-tangle=.

In order to load the file, put into your =~/.emacs= or
=~/.emacs.d/init.el=:

#+BEGIN_SRC elisp :tangle no
(load-file "~/.emacs.d/build/init-main.el")
(server-start)
#+END_SRC

* General settings
** Home directory

Let's define our own constant for the emacs directory and a function
to get subdir:

#+BEGIN_SRC elisp
  (defconst ra/emacs-directory (concat (getenv "HOME") "/.emacs.d/"))
  (defun ra/emacs-subdirectory (d) (expand-file-name d ra/emacs-directory))
#+END_SRC


I don't recall why I still have this setting, but let it be:

#+BEGIN_SRC elisp
(setq emacs-root-dir user-emacs-directory)
#+END_SRC

** Load system-specific overrides

We might have some local custom stuff around (e.g. brew location of
erlang), so let's look up that in machine-specific file:

#+BEGIN_SRC elisp
  (setq ra/emacs-machine-init
        (expand-file-name (concat system-name ".el") ra/emacs-directory)
        )

  ;; (setq custom-file (expand-file-name "init-local.el" ra/emacs-directory))
  (when (file-exists-p ra/emacs-machine-init)
    (load ra/emacs-machine-init))
#+END_SRC

** Setup load paths

I  have two  load  paths, =lisp=  for  v1 logic  and  =build= for  the
literate version (or v2):

#+BEGIN_SRC elisp
(add-to-list 'load-path (ra/emacs-subdirectory "lisp"))
(add-to-list 'load-path (ra/emacs-subdirectory "build"))
#+END_SRC

* Helper functions

Just a few helper functions to lighten up the day
#+BEGIN_SRC elisp

(defun add-hook-list (callback hooks)
  "Adds callback to each one of the hooks."
  (mapc (lambda (hook)
	  (add-hook hook callback))
	hooks))


#+END_SRC
* Load Packages
Load el-get and let it load all packages in a folder


#+BEGIN_SRC elisp

;; load el-get
(add-to-list 'load-path (expand-file-name "el-get/el-get" emacs-root-dir))

(unless (require 'el-get nil 'noerror)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.github.com/dimitri/el-get/master/el-get-install.el")
    (let (el-get-master-branch)
      (goto-char (point-max))
      (eval-print-last-sexp))))


;; load all .el files inside `modules-dir`
(setq modules-dir (expand-file-name "lisp/packages" emacs-root-dir))
(mapc 'load (directory-files modules-dir 't "^[^#].*el$"))

;; install all missing packages via el-get
(el-get 'sync (mapcar 'el-get-source-name el-get-sources))

#+END_SRC

* Display settings

** Hide some things
#+BEGIN_SRC elisp
;; I know what the scratch is for
(setq initial-scratch-message "")

;; don't show the startup help screen
(setq inhibit-startup-screen t)

;; disable alarm bell beep
(setq visible-bell t)
#+END_SRC

** Load GUI settings

   If we are running in a windowed environment where we can set up
   fonts and whatnot, init mac stuff... which will still work for
   Linux too. Script is located in a seprate [[file:emacs-client.org][initialization file]].

   #+BEGIN_SRC elisp
     (when (window-system)
       (require 'init-client)
       )
   #+END_SRC

** Windows

#+BEGIN_SRC elisp
  ;; move to a neighbor window using SHIFT-<arrow-key>
  (windmove-default-keybindings)

  ;; don't conflict with orgmode
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right)

#+END_SRC

I don't think, I use these any longer:

#+BEGIN_SRC elisp :tangle no
  ;; enlarge and shrink windows
  (global-set-key (kbd "C-c <up>")    'shrink-window)
  (global-set-key (kbd "C-c <right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "C-c <down>")  'enlarge-window)
  (global-set-key (kbd "C-c <left>")  'shrink-window-horizontally)
#+END_SRC

* Navigation

** Dired

Dired can work like a total commander and guess targets when two
windows are open:
#+BEGIN_SRC elisp
(setq dired-dwim-target t)
#+END_SRC

* Editing experience

** VIM emulation

Evil emulates vim inside emacs. It works pretty well out of the box:

#+BEGIN_SRC elisp
(require `evil)
;;(key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
(evil-mode 1)

#+END_SRC

Something that I can't get used to is to disable cursor keys:

#+BEGIN_SRC elisp :tangle no

;;Motion state map disables the cursor keys in normal, operator, visual
;; as well as the special motion states.
(define-key evil-insert-state-map [left] 'undefined)
(define-key evil-insert-state-map [right] 'undefined)
(define-key evil-insert-state-map [up] 'undefined)
(define-key evil-insert-state-map [down] 'undefined)

(define-key evil-motion-state-map [left] 'undefined)
(define-key evil-motion-state-map [right] 'undefined)
(define-key evil-motion-state-map [up] 'undefined)
(define-key evil-motion-state-map [down] 'undefined)

#+END_SRC

** Parentheses

Highlight matching parens:
#+BEGIN_SRC elisp
(show-paren-mode t)
#+END_SRC

** Cursor


Make the cursor blink:

#+BEGIN_SRC elisp
;; blinking cursor
(blink-cursor-mode t)
#+END_SRC

** IDO (Interactively DO stuff)


I love IDO:
#+BEGIN_SRC elisp
(ido-mode t)
#+END_SRC

** Auto-load changes

When file wasn't modified, reload changes automatically:

#+BEGIN_SRC elisp
(global-auto-revert-mode t)
#+END_SRC

** UTF8 Encoding

C'mon, it is 21st century already. Set environment coding system to UTF8:

#+BEGIN_SRC elisp
(set-language-environment "UTF-8")
#+END_SRC

** Yasnippet

Yasnipped lets you define snippets of code for different languages:

#+BEGIN_SRC elisp
(require 'yasnippet)
(yas-global-mode)
#+END_SRC


Inside the snippets directory should be directories for each mode,
e.g. clojure-mode and org-mode. This connects the mode with the
snippets.

#+BEGIN_SRC elisp
(setq yas-snippet-dirs (ra/emacs-subdirectory "snippets"))
#+END_SRC

** Key chords

Let's enable key-chord:

#+BEGIN_SRC elisp
(require `key-chord)
(key-chord-mode 1)
#+END_SRC

My current key bindings

#+BEGIN_SRC elisp
  (key-chord-define-global ";b" 'ibuffer)


  (defun find-tag-no-prompt ()
    "Jump to the tag at point without prompting"
    (interactive)
    (find-tag (find-tag-default)))

  (defun view-tag-other-window (tagname &optional next-p regexp-p)
    "Same as `find-tag-other-window' but doesn't move the point"
    (interactive (find-tag-interactive "View tag other window: "))
    (let ((window (get-buffer-window)))
      (find-tag-other-window tagname next-p regexp-p)
      (recenter 0)
      (select-window window)))

  (key-chord-define-global "5t" 'find-tag-default)

  (key-chord-define-global "4t" 'view-tag-other-window)

  (key-chord-define-global ";d" 'dired-jump)

  (key-chord-define-global ";'" 'execute-extended-command) ;; Meta-X

  (key-chord-define-global ";l" 'ido-switch-buffer)
  (key-chord-define-global ";." 'ido-find-file) ;; jump to file

  (defun kill-this-buffer-if-not-modified ()
    (interactive)
    (if (menu-bar-non-minibuffer-window-p)
        (kill-buffer-if-not-modified (current-buffer))
      (abort-recursive-edit)))
  (key-chord-define-global ";k"     'kill-this-buffer-if-not-modified)


  ;; SAVE
  (defun save-and-recompile()
    (interactive)
    (save-buffer)
    (recompile)
    )

  (global-set-key (kbd "<f2>") `save-and-recompile)
  (global-set-key (kbd "<f8>") `recompile)
  (global-set-key (kbd "<f9>") `next-error)

#+END_SRC

* Miscellaneous
** Unknown origins

This was copied from somewhere, not sure if I still need these:

#+BEGIN_SRC elisp
;; mode line settings
(column-number-mode t)
(line-number-mode t)
(size-indication-mode t)

;; set your desired tab width
(setq-default indicate-empty-lines t)
#+END_SRC

Another unknown bit:

#+BEGIN_SRC elisp :tangle no

;; S-up does not work properly in terminals
;; http://lists.gnu.org/archive/html/help-gnu-emacs/2011-05/msg00211.html
 (if (equal "xterm" (tty-type))
      (define-key input-decode-map "\e[1;2A" [S-up]))

(defadvice terminal-init-xterm (after select-shift-up activate)
  (define-key input-decode-map "\e[1;2A" [S-up]))

#+END_SRC

and one more:

#+BEGIN_SRC elisp :tangle no

  ;; This won't affect the size of the emacs window, but the term process will always think the window is 80 columns wide
  (defun term-window-width () 80)
  ;;  turn on line truncation
  (add-hook 'term-mode-hook
        (lambda () (setq truncate-lines t)))
#+END_SRC

** Tabs vs Spaces

Let's stick with tabs for now:


#+BEGIN_SRC elisp

;; display tab chars as 4
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)

#+END_SRC

** Enable Y/N answers

=y= is shorter than =yes=:
#+BEGIN_SRC elisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable auto-save

Auto-save never really worked for me:
#+BEGIN_SRC elisp
(setq make-backup-files nil)
(setq auto-save-default nil)

#+END_SRC

** Line numbers 

#+BEGIN_SRC elisp

(global-linum-mode 1)

(defconst linum-mode-excludes '(
                                doc-view-mode
                                compilation-mode
                                term-mode
                                dired-mode
                                ibuffer-mode
                                eshell-mode
                                )
  "List of major modes preventing linum to be enabled in the buffer.")

(defadvice linum-mode (around linum-mode-selective activate)
  "Avoids enabling of linum-mode in the buffer having major mode set to one
of listed in `linum-mode-excludes'."
  (unless (member major-mode linum-mode-excludes)
    ad-do-it))

#+END_SRC

And highlight current line:
#+BEGIN_SRC elisp

;; highlight current line
(add-hook 'after-change-major-mode-hook 'hl-line-mode)

#+END_SRC

* Languages

** Erlang

Default erlang distribution has great setup for emacs. We just need to
wire it together, provided there was an erlang installation.

On OSX you could install erlang via:

#+BEGIN_SRC sh :tangle no
brew install erlang
#+END_SRC

And then define in machine-local file something like:

#+BEGIN_SRC elisp :tangle no
(setq ra/erlang-path "/usr/local/Cellar/erlang/17.5/")
#+END_SRC

Erlang-specific config is:

#+BEGIN_SRC elisp :tangle build/init-erlang.el
  (when
      (boundp 'ra/erlang-path)
  
    (setq erlang-root-dir (concat ra/erlang-path "/lib/erlang/lib"))
    (setq erlang-emacs-path (concat ra/erlang-path "/lib/erlang/lib/tools-2.7.2/emacs"))
    (setq erlang-bin-path (concat ra/erlang-path "/lib/erlang/bin"))
    (setq load-path (cons erlang-emacs-path load-path))
    (setq exec-path (cons erlang-bin-path exec-path))
    (require 'erlang-start)
   
    )

  (provide 'init-erlang)

#+END_SRC

We can load it from the main file:

#+BEGIN_SRC elisp
(require 'init-erlang)
#+END_SRC

** Pure Javascript

#+BEGIN_SRC elisp :tangle build/init-js.el
  (require `company)
  (require `flycheck)
  (require `yasnippet)
  (require `jsfmt)
  ;;(add-hook `js-mode-hook `flycheck-mode)
  ;;(add-hook `js-mode-hook `company-mode)

  (add-hook 'before-save-hook 'jsfmt-before-save)
  (add-hook 'js-mode-hook
            (lambda ()
              ;; activate on-the-fly-check (will use installed linter)
  ;;            (flycheck-mode)
              ;; auto-completion
              (company-mode)
              ;; Activate the folding mode
  ;;            (hs-minor-mode t)
              ;; snippets
              (yas-minor-mode)

          
              ;; perform flycheck on save
              (setq flycheck-check-syntax-automatically '(save))
              ;; run flycheck here
              (flycheck-mode)

              )
            )


  (setq js-indent-level 4)

  (provide 'init-js)
#+END_SRC

And load this config via:

#+BEGIN_SRC elisp
(require 'init-js)
#+END_SRC

** Golang mode

As it was imported from my previous config:

#+BEGIN_SRC elisp build/init-go.el
  (require 'go-mode)
  (require 'key-chord)
  (require 'company-go)
  (require 'go-eldoc)
  (require 'yasnippet)

  (setq gofmt-command "goimports")
  (add-hook 'before-save-hook 'gofmt-before-save)


   ;; jump to file
  (key-chord-define go-mode-map "5t" 'godef-jump)
  (key-chord-define go-mode-map "4t" 'godef-jump-other-window)


  (defun my-go-mode-hook ()
    ;; customize compile command
    ;; (if (not (string-match "go" compile-command))
    ;;     (set (make-local-variable 'compile-command)
    ;;          "go vet && go test"))

    ;; go uses tabs
    (setq indent-tabs-mode t)
    (setq tab-width 4)
    (yas-minor-mode)

    (set (make-local-variable 'company-backends) '(company-go))        
    (company-mode) 
    (go-eldoc-setup)

    (local-set-key (kbd "M-.") 'godef-jump)
    )                              

  (add-hook 'go-mode-hook 'my-go-mode-hook)

  (provide 'init-go)

#+END_SRC

** Web editing

Web mode that is also used to edit mixed files like JSX

#+BEGIN_SRC elisp :tangle build/init-web.el
  (require 'web-mode)
  (require 'yasnippet)
  (require 'company)

  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.hbs\\'" . web-mode))

  ;; activate JSX mode
  (add-to-list 'auto-mode-alist '("\\.jsx$" . web-mode))

  (defun my-web-mode-hook ()
    "Hooks for Web mode."
    (setq web-mode-markup-indent-offset 4)
    (setq web-mode-code-indent-offset 4)
    ; YAS has to be loaded before company
    (yas-minor-mode 1)
    (setq indent-tabs-mode t)
    (company-mode)


    (add-hook 'before-save-hook 'whitespace-cleanup)
  )
  (add-hook 'web-mode-hook  'my-web-mode-hook)


  ;; auto-completion sources


   (setq web-mode-ac-sources-alist
         '(
           ("html" . (ac-source-yasnippet))
           ))

  (add-hook 'web-mode-before-auto-complete-hooks
            '(lambda ()
               (let ((web-mode-cur-language
                      (web-mode-language-at-pos)))
                 (if (string= web-mode-cur-language "html")
                     (yas-activate-extra-mode 'html-mode)
                   (yas-deactivate-extra-mode 'html-mode))
                 )))





  (defadvice web-mode-highlight-part (around tweak-jsx activate)
    (if (equal web-mode-content-type "jsx")
        (let ((web-mode-enable-part-face nil))
          ad-do-it)
      ad-do-it))

  ;; JSX syntax checking

  (flycheck-define-checker jsxhint-checker
    "A JSX syntax and style checker based on JSXHint."
  ;; We need to use source-inplace because eslint looks for
              ;; configuration files in the directory of the file being checked.
              ;; See https://github.com/flycheck/flycheck/issues/447
    :command ("eslint" "--format=checkstyle" source-inplace)
     :error-parser flycheck-parse-checkstyle
    :error-filter (lambda (errors)
                    (mapc (lambda (err)
                            ;; Parse error ID from the error message
                            (setf (flycheck-error-message err)
                                  (replace-regexp-in-string
                                   (rx " ("
                                       (group (one-or-more (not (any ")"))))
                                       ")" string-end)
                                   (lambda (s)
                                     (setf (flycheck-error-id err)
                                           (match-string 1 s))
                                     "")
                                   (flycheck-error-message err))))
                          (flycheck-sanitize-errors errors))
                    errors)
    :modes (web-mode)
    )


  (add-hook 'web-mode-hook
            (lambda ()
              (when (equal web-mode-content-type "jsx")
                ;; enable flycheck
                (flycheck-select-checker 'jsxhint-checker)
                (flycheck-mode)
                ;;
                (add-hook 'web-mode-hook #'(lambda () (yas-activate-extra-mode 'jsx-mode)))



                )))


  (provide 'init-web)
#+END_SRC

and we can load it from the main file:

#+BEGIN_SRC elisp
(require 'init-web)
#+END_SRC

** Org-mode
Org-mode setup is located in a separate [[file:emacs-org.org][init file]], we just load it
here:

#+BEGIN_SRC elisp
(require 'init-org)
#+END_SRC

* Footnotes

** Loading the configuration

To reload with a require:


#+BEGIN_SRC elisp
(provide 'init-main)

#+END_SRC
